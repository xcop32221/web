# DAY2

### 箭头函数(arrow function)

```js
1.基本语法：
//1. 箭头函数 
const fn1 = () => {
  console.log(123)
}
fn1()
// 2. 只有一个形参的时候，可以省略小括号
// 3. 只有一行代码的时候，我们可以省略大括号
// 4. 只有一行代码的时候，可以省略return/如果省略return就不要加花括号了
// 5. 箭头函数可以直接返回一个对象, 但必须在对象外面加上括号

2.内部具有rest数组
3.对象方法不推荐使用箭头函数

```

### 解构赋值(deconstruction)

```js
1.变量赋值
2.函数传参

//数组结构
概念：数组元素快速赋值给变量；按顺序结构
基本语法： let [a,b,c]=[1,2,3]
1.可以用rest数组接收数组，只能放最后
2.可以使用默认值 let [a=1,b=2]=[]
3.变量赋值时左边是数组右边就需要是数组
作用：
1.交换两个变量：[a,b] = [b,a]
//JS中需要加分号，这些token会被js解析为一行
1.（）立即执行函数
2. [] 数组

//多维数组解构
解构赋值是一种模式匹配：左侧和右侧应该长的一样
let [aa,bb,...cc]=['a']//a undefined []
如果解构不成功，变量的值就是undefined



//对象结构
概念：将对象属性和方法赋值给变量；按属性名结构
语法：{属性名，属性名，...}=对象
1.先找到同名的属性，再赋值给相应的变量
2.如果有冒号重命名的，被赋值的是冒号后面的新变量//每当一个冒号出现，冒号左边就是查找对应位置，右边就是赋值目标
3.要求冒号前的变量名必须和属性名一致
4.可以使用rest数组，其返回值为剩余属性组成的对象
//对象结构更改变量名
{旧变量名：新变量名}=obj
//解构对象池
[{属性名：新属性名，属性名：新属性名}]=对象池
//多级对象结构
{属性名，内置对象:{属性名...}}=obj

//利用解构向函数传参：
使用：数据解构形式放在形参位置，去接收对应的数据
目的：想要把数组，对象中的元素，属性值当做参数放入函数中，利用解构直接调用时传入数组，对象//向函数形参传递的解构，是用let定义的参数

```

### 数组filter方法

```js
1.作用：创建一个新的数组，新数组的元素是筛选后的元素
2.参数：array.filter接收一个函数，函数接收两个参数
第一个参数：正在处理的元素
第二个参数：index索引号
3.返回值：由满足条件的元素组成的新数组
4.步骤：将所有元素放入回调函数中，返回值为ture(普通函数return，箭头函数简写一行的形式不用)的放入新数组中

// 1. filter过滤 得到一个新的数组，元素的个数一般会减少
const resFilter = arr.filter(el => el > 30)
console.log(resFilter)
// 2. map映射 一对一  [1, 2, 3] ===> [a, b, c]
const resMap = arr.map(el => el + 6)
console.log(resMap)
```

### 对象

```js
#对象：属性和方法的无序集合
属性：事物的特征
方法：事物的行为

创建对象：
1.字面量：{}
2.构造函数：new Object()
3.指定原型: Object.creat(原型对象，增强属性对象)

不用继承对象增强：
//静态属性增强：
1.点语法增加属性
2.Object.Assign(自身，增强对象)
//方法增强：
1.点语法添加方法
2.使用其他类型的方法：使用call/bind传入this盗用方法

#构造函数
返回值：省略return this/如果有返回值对象，则返回该对象
1. 构造函数，相当于一个模板，可以创建一系列具有相同属性和方法的对象
2. 通过构造函数创建对象的过程，就叫做实例化    ==> new 出一个对象的过程
3. 创建好的这个对象  ==> 实例  / 实例对象
// 注意: 
1. 构造函数名字首字母要大写
2. 构造函数里 属性和方法前面必须添加 this
3. 构造函数不需要 return 就可以返回结果
4. 我们调用构造函数 必须使用 new

//构造函数的执行过程
1.创建一个空对象
2.让this指向这个空对象
3.构造函数里面的代码，给这个对象添加属性和方法
4.返回这个对象

//静态成员：
在构造函数本身添加的属性和方法
通过构造函数来访问

静态方法：Array.from()....

//基本包装类型
```

