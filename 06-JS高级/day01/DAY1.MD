# DAY1

### 作用域：

```js
/Scope:变量和函数的可访问范围，控制变量和函数的可见性和声明周期
1.全局作用域：直接写在script或者js代码，属于全局作用域
可见性：在代码的任何地方都可以访问
生命周期：随着页面的生命周期(页面关闭，销毁)
//函数内部如果不使用关键词声明，这个变量会成为window的属性

2.局部作用域：函数作用域
可见性：函数外部不能访问函数内部的变量
生命周期：变量在函数调用执行后，就会被销毁

3.块级作用域
为什么需要块级作用域：
1.内层变量可能覆盖外层变量
2.用来计数的循环变量，防止外溢
特点：
1.{}包裹起来叫做代码块，使用let或者const声明的变量，会在{}里面产生块级作用域
2.块级作用域外部不能访问内部变量
3.块级作用域相互不影响
4.if/for是语句，但是用let和const声明，会在内部形成块级作用域
  
// 什么是作用域链？
1.函数是可以嵌套函数的，每个函数都有一个局部作用域，这样子，也会形成作用域的嵌套
2.当访问内层作用域中的某个变量的时候，首先在当前作用域中查找这个变量，如果不存在，往上层查找，直到全局作用域
```

### 垃圾回收：

```js
#内存的生命周期：
1.内存分配
2.内存使用
3.内存回收
//全局变量一般不会回收，局部变量一般在失去引用时就会回收
//垃圾回收在JS中自动进行
内存泄露：不用的内存，一直占用，没有即时释放

#垃圾回收策略
定期查找不用的内存(变量)，然后清除掉
1.标记清理(主流)：Mark-Sweep
//周期性的
阶段：
1.标记阶段：标记活动和非活动对象/使用bit反转等方法
//从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能访问到的元素称为活动对象，不能访问到的判断为垃圾数据
2.清除阶段：清除垃圾对象
缺陷：
内存碎片化：如果存储大的连续数据会无法放在清除后的位置上
3.整理阶段：Mark-Compact
1.标记空间中活动和非活动对象
2.回收非活动对象所占用的内存
3.内存整理


2.引用计数：
//不是周期性的
机制：
1.跟踪记录每个值被引用的次数
2.引用一次则记录次数加1
3.多次引用累计
4.如果减少一个引用则减1
5.引用次数为0时，释放内存
缺陷：
循环引用：在局部作用域中出现循环引用，会导致其引用一直存在，不会被内存清理，造成内存泄露

```

### 闭包

```js
定义：closure
//也是一种scope
1.闭包是指有权访问另一个函数作用域中的变量的函数
2.闭包是指那些引用了另一个函数作用域变量的函数，通常在函数嵌套实现
3.闭包是一个函数以及其捆绑的周边环境状态(词法环境)的引用组合，闭包会随着函数的创建而创建
4.#闭包是内层函数引用外层函数变量的集合
闭包=内层函数+外层函数的变量//绑定关系

条件：
1.要有内层函数
2.内层函数使用了外层函数的变量
闭包的简写：外层函数直接返回值直接为内层函数本身

特性：
1.让外部可以访问函数内部的变量
2.让变量私有化

实际运用：
1.节流throttle
2.防抖debounce

缺陷：
内存泄露：内层函数一直去引用外层函数变量；则外层函数的变量不会被清除

```

### arguments对象

```js
//arguments对象--箭头函数没有
作用：动态的获取函数的实参
1.除箭头函数以外，所有函数都内置了arguments对象。
2.arguments是伪/类数组，接收了我们传递过来的实参。
3.这个对象只存在于函数中。

//rest数组--箭头函数有
形式：...变量名//变量名自定义
1.rest是一个真数组，存的剩余的实参
2.只能放在参数的最后一个位

//拓展运算符
形成：...可迭代对象
作用：将一个数组转换成一个参数列表，是rest的逆运算/不会改变原数组
应用：
1.求一个数组的最大最小值 Math.max(...arr)
2.合并数组 arr2=[...arr1,...arr2]
3.拷贝数组 arr2=[...arr1]//浅拷贝：如果元素是引用类型更改会有影响
//数组里面的元素是基本数据类型，修改元素的值，相互不影响
4.展开字符串 arr=[...'string']


//按作用去区分rest参数和拓展运算符
```

### 

